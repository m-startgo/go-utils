# Copilot / AI 说明（供代码助理使用）

下面的说明专注于让 AI 编码代理能快速在此仓库中开展工作：这是一个以 Go 为主的工具库（module: `github.com/m-startgo/go-utils`，Go 版本 1.25），按「mXxx」子包划分常用工具函数，每个子包都很小且通过单元测试做为使用示例。

核对清单（我会遵循这些项）：

- 理解仓库结构与模块路径（`go.mod`）
- 优先读取 `README.md` 与各子包的 `_test.go` 用例作为用法参考
- 使用 `go test ./...`、`go test ./pkg -run TestName -v` 做验证
- 遵循本仓库的命名/导出约定与小型函数风格

快速背景（大局观）

- 本库是一个通用工具集合，按功能拆成多个包：`mcron`, `mcycle`, `mfile`, `mhttp`, `mjson`, `mlog`, `mmath`, `mpath`, `mstr`, `mtime`, `mverify`。
- 每个包通常只有一个或少量源文件和对应的 `_test.go`，测试文件常被用作示例/用法说明（例如 `README.md` 中引用了 `m_str.TplFormat`）。
- 依赖在 `go.mod` 中声明：`github.com/robfig/cron/v3`、`github.com/shopspring/decimal`、`github.com/araddon/dateparse`。

项目约定和可发现的模式（重要，避免泛泛而谈）

- 包名前缀：所有包目录以 `m` 开头（例如 `mfile`, `mstr`），内部函数导出遵循 Go 习惯（首字母大写导出）。
- 测试即文档：查看对应包的 `_test.go` 文件是理解 API 和边界条件的首选方式（例如 `mfile/file_test.go`、`mmath/all_test.go`）。
- 单文件小工具：很多功能实现集中在单个文件（如 `mcron/New.go`, `mtime/time.go`, `mpath/path.go`），代码风格偏实用、不依赖复杂框架。
- 命名差异：部分源码文件名用首字母大写（如 `Join.go`, `ToStr.go`），这对 Go 构建无影响，但注意搜索时区分大小写。

常用开发/验证命令（在 Windows PowerShell 中）：

```powershell
# 运行所有单元测试
go test ./... -v

# 运行单个包的测试并查看具体用例
go test ./mfile -run TestReaddir -v

# 构建/安装（作为库使用时常用）
go install github.com/m-startgo/go-utils@latest

# 格式化与静态检查
gofmt -w .
go vet ./...
```

集成点与注意事项

- 这是一个库（非可执行服务）。外部项目通过 `module` 路径 `github.com/m-startgo/go-utils/<pkg>` 导入特定包。
- 由于很多函数是小而纯粹的工具函数（无全局状态），变更通常影响面较小，但在修改公共导出函数时请检查并更新对应 `_test.go` 示例。

快速查找方向（作为 AI 的第一步）

- 先读 `go.mod` → `README.md` → 各包的 `_test.go`。
- 若要实现/修改功能，打开对应包目录（例如 `mstr` 或 `mfile`）并运行其测试用例作为回归基线。

示例引用（在仓库中可直接查看）

- `README.md`：展示了 `m_str.TplFormat` 的使用示例。
- `mcron/New.go`：cron 相关工具封装，依赖 `github.com/robfig/cron/v3`。
- `mmath/decimal.go`：使用 `shopspring/decimal` 管理小数精度。

变更与贡献小提示（用于自动补丁和 PR）

- 修改公共 API：同时更新对应 `_test.go` 并确保 `go test ./...` 通过。
- 小的修复或新工具：尽量在单一包内完成，保持变更原子且有测试覆盖。

反馈请求

- 我已把此说明写入本文件供后续 AI 代理使用；请指出是否需要补充特定包的额外约定或任何常见陷阱，我会据此更新说明。

## 通用规则（ Copilot 需要尽量遵照以下规则进行工作 ）

1. **语言规范**：用户可见文本（UI/提示/日志）使用中文；代码、命令、技术术语使用英文以保证准确性与跨平台兼容性。提交信息、README 可混合中英，但技术示例以英文为准。
2. **跨平台兼容**：生成代码应优先兼容 Windows/Linux/macOS。若使用 OS 特性，需在注释中标注受影响平台并提供替代方案或回退逻辑。如无法兼容，需在注释中说明原因及影响。
3. **函数注释**：所有函数/方法必须包含规范注释，说明功能、参数、返回值及可能的异常。
4. **库选择**：优先使用标准库或主流维护库。选择第三方库时需说明推荐版本、许可证（MIT/Apache 优先）、安全评估（是否有已知漏洞）。实验性库必须在注释中标注风险并 pin 版本。
5. **代码风格**：遵循目标语言的官方风格指南和命名规范。
6. **函数设计**：避免过长或职责不单一的函数；提倡小函数、清晰职责、易测性。
7. **需求澄清**：遇到模糊或信息不足的请求，立即提出具体澄清问题（列出缺失项和可选方案），不得自行假设关键约束。
8. **语法实践**：保持向后兼容，避免使用弃用特性；优先使用最新稳定语法与实践，并在必要时在注释中说明兼容策略。
9. **错误处理**：错误日志需包含可追溯信息，格式：`err:<包名.函数名>|<操作场景>|<错误信息>`。
10. **可测试性**：生成代码时考虑可测试性，必要时提供单元测试或测试建议。
11. **响应风格**：回复简洁直接，优先给出可运行代码或明确修改建议；多方案时列出优劣并给出推荐。若内容较长，先给简要结论再附详情。
12. **方案评估**：若有多种实现方案，列出优劣并基于稳定性、兼容性、维护成本给出推荐。
13. **版本假设**：：默认遵循最新稳定版本（以官方 release/semver stable tag 为准）；如需特定版本或有特殊约束，应在请求中明确。
14. **上下文感知**：生成代码时充分考虑当前文件的上下文（如已导入的库、现有函数等）。
15. **性能考量**：必要时提供性能优化建议，如避免不必要的计算、合理使用缓存等。
16. **安全实践**：提醒潜在的安全风险（如注入攻击、敏感信息暴露等）并提供防范建议。
